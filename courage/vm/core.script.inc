static const char* coreModuleCode = 
"class Null {}\n"
"class Bool {}\n"
"class Num {}\n"
"class Fn {}\n"
"class Thread {}\n"
"\n"
"class Sequence {\n"
"   all(f) {\n"
"      let result = true\n"
"      for element (this) {\n"
"         result = f.call(element)\n"
"         if (!result) return result\n"
"      }\n"
"      return result\n"
"   }\n"
"\n"
"   any(f) {\n"
"      let result = false\n"
"      for element (this) {\n"
"         result = f.call(element)\n"
"         if (result) return result\n"
"      }\n"
"      return result\n"
"   }\n"
"\n"
"   contains(element) {\n"
"      for item (this) if (element == item) return true\n"
"      return false\n"
"   }\n"
"\n"
"   length {\n"
"      let result = 0\n"
"      for element (this) result = result + 1\n"
"      return result\n"
"   }\n"
"\n"
"   length(f) {\n"
"      let result = 0\n"
"      for element (this) if (f.call(element)) result = result + 1\n"
"      return result\n"
"   }\n"
"\n"
"   each(f) {\n"
"      for element (this) f.call(element)\n"
"   }\n"
"\n"
"   isEmpty {\n"
"      return iterate(null) ? false : true\n"
"   }\n"
"\n"
"   map(transformation) {\n"
"      return MapSequence.new(this, transformation)\n"
"   }\n"
"\n"
"   where(predicate) {\n"
"      return WhereSequence.new(this, predicate)\n"
"   }\n"
"\n"
"   reduce(acc, f) {\n"
"      for element (this) acc = f.call(acc, element)\n"
"      return acc\n"
"   }\n"
"\n"
"   reduce(f) {\n"
"      let iter = iterate(null)\n"
"      if (!iter) Thread.abort(\"Can't reduce an empty sequence.\")\n"
"      let result = iteratorValue(iter)\n"
"      while (iter = iterate(iter)) result = f.call(result, iteratorValue(iter))\n"
"      return result\n"
"  }\n"
"\n"
"   join(sep) {\n"
"      let first = true\n"
"      let result = \"\"\n"
"      for element (this) {\n"
"         if (!first) result = result + sep\n"
"         first = false\n"
"         result = result + element.toString\n"
"      }\n"
"      return result\n"
"   }\n"
"\n"
"   join() {\n"
"      return join(\"\")\n"
"   }\n"
"\n"
"   toList {\n"
"      let result = List.new()\n"
"      for element (this) result.add(element)\n"
"      return result\n"
"   }\n"
"}\n"
"\n"
"class MapSequence < Sequence {\n"
"   let sequence\n"
"   let fn\n"
"   new(seq, f) {\n"
"      sequence = seq\n"
"      fn = f\n"
"   }\n"
"\n"
"  iterate(iterator) { \n"
"     return sequence.iterate(iterator)\n"
"  }\n"
"  iteratorValue(iterator) {\n"
"     return fn.call(sequence.iteratorValue(iterator))\n"
"  }\n"
"}\n"
"\n"
"class WhereSequence < Sequence {\n"
"   let sequence\n"
"   let fn\n"
"   new(seq, f) {\n"
"      sequence = seq\n"
"      fn = f\n"
"   }\n"
"\n"
"   iterate(iterator) {\n"
"      while (iterator = sequence.iterate(iterator)) \n"
"        if (fn.call(sequence.iteratorValue(iterator))) break\n"
"      return iterator\n"
"   }\n"
"\n"
"   iteratorValue(iterator) {\n"
"      return sequence.iteratorValue(iterator)\n"
"   }\n"
"}\n"
"\n"
"class String < Sequence {\n"
"   bytes { \n"
"      return StringByteSequence.new(this)\n"
"   }\n"
"   codePoints {\n"
"      return StringCodePointSequence.new(this)\n"
"   }\n"
"\n"
"   *(length) {\n"
"      if (!(length is num) || !length.isInteger || length < 0) \n"
"         Thread.abort(\"Length must be a non-negative integer.\")\n"
"      let result = \"\"\n"
"      for i (0..(length - 1)) result = result + this\n"
"      return result\n"
"   }\n"
"}\n"
"\n"
"class StringByteSequence < Sequence {\n"
"   let string\n"
"   new(str) {\n"
"      string = str\n"
"   }\n"
"\n"
"   [index] { \n"
"      return string.byteAt_(index)\n"
"   }\n"
"   iterate(iterator) {\n"
"      return string.iterateByte_(iterator) \n"
"   }\n"
"   iteratorValue(iterator) {\n"
"      return string.byteAt_(iterator) \n"
"   }\n"
"\n"
"   length { \n"
"      return string.byteCount_ \n"
"   }\n"
"}\n"
"\n"
"class StringCodePointSequence < Sequence {\n"
"   let string\n"
"   new(str) {\n"
"      string = str\n"
"   }\n"
"\n"
"   [index] { \n"
"      return string.codePointAt_(index)\n"
"   }\n"
"   iterate(iterator) {\n"
"      return string.iterate(iterator) \n"
"   }\n"
"   iteratorValue(iterator) {\n"
"      return string.codePointAt_(iterator)\n"
"   }\n"
"\n"
"   length {\n"
"      return string.length \n"
"   }\n"
"}\n"
"\n"
"class List < Sequence {\n"
"   push(other) {\n"
"      add(other)\n"
"   }\n"
"\n"
"   addAll(other) {\n"
"      for element (other) add(element)\n"
"      return other\n"
"   }\n"
"\n"
"   toString {\n"
"      return \"[%(join(\",\"))]\" \n"
"   }\n"
"\n"
"   +(other) {\n"
"      let result = this[0..-1]\n"
"      for element (other) result.add(element)\n"
"      return result\n"
"   }\n"
"\n"
"   *(length) {\n"
"      if (!(length is num) || !length.isInteger || length < 0) \n"
"         Thread.abort(\"Length must be a non-negative integer.\")\n"
"      let result = []\n"
"      for i (0..(length - 1)) result.addAll(this)\n"
"      return result\n"
"   }\n"
"}\n"
"\n"
"class Map {\n"
"   keys { \n"
"      return MapKeySequence.new(this) \n"
"   }\n"
"   values {\n"
"      return MapValueSequence.new(this)\n"
"   }\n"
"\n"
"   toString {\n"
"      let first = true\n"
"      let result = \"{\"\n"
"\n"
"      for key (keys) {\n"
"         if (!first) result = result + \", \"\n"
"         first = false\n"
"         result = result + \"%(key): %(this[key])\"\n"
"      }\n"
"\n"
"      return result + \"}\"\n"
"   }\n"
"}\n"
"\n"
"class MapKeySequence < Sequence {\n"
"   let map\n"
"   new(mp) {\n"
"      map = mp\n"
"   }\n"
"\n"
"   iterate(n) {\n"
"      return map.iterate_(n) \n"
"   }\n"
"   iteratorValue(iterator) {\n"
"      return map.keyIteratorValue_(iterator)\n"
"   }\n"
"}\n"
"\n"
"class MapValueSequence < Sequence {\n"
"    let map\n"
"    new(mp) {\n"
"       map = mp\n"
"    }\n"
"\n"
"   iterate(n) {\n"
"      return map.iterate_(n) \n"
"   }\n"
"   iteratorValue(iterator) {\n"
"      return map.valueIteratorValue_(iterator) \n"
"   }\n"
"}\n"
"\n"
"class Range < Sequence {}\n"
"\n"
"class console{\n"
"   static log(obj) {\n"
"      System.print(obj)\n"
"   }\n"
"}\n"
"\n"
"class System {\n"
"   static print() {\n"
"      writeString_(\"\n\")\n"
"   }\n"
"\n"
"   static print(obj) {\n"
"      writeObject_(obj)\n"
"      writeString_(\"\n\")\n"
"      return obj\n"
"   }\n"
"\n"
"   static printAll(sequence) {\n"
"      for object (sequence) writeObject_(object)\n"
"      writeString_(\"\n\")\n"
"   }\n"
"\n"
"   static write(obj) {\n"
"      writeObject_(obj)\n"
"      return obj\n"
"   }\n"
"\n"
"   static writeAll(sequence) {\n"
"      for object (sequence) writeObject_(object)\n"
"   }\n"
"\n"
"   static writeObject_(obj) {\n"
"      let str = obj.toString\n"
"      if (str is String) {\n"
"         writeString_(str)\n"
"      } else {\n"
"         writeString_(\"[invalid toString]\")\n"
"      }\n"
"   }\n"
"}\n";
